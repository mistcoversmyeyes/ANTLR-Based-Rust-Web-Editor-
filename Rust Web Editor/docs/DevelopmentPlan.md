# 后续开发计划

## 第一阶段：完善核心前端功能 (Web编辑器)

这个阶段的目标是完成 `README.md` 中要求的基础功能，将项目从一个本地分析器转变为一个功能完备的网页编辑器。

1.  **搭建Web服务器**:
    *   **任务**: 在 `RustAnalyser` 项目中集成一个轻量级的Java Web服务器（Javalin）。
    *   **目的**: 创建一个API端点（例如 `/analyse`），使其能够接收来自网页前端的Rust代码字符串。

2.  **构建完整的错误处理机制**:
    *   **任务**: 实现ANTLR的 `ANTLRErrorListener` 接口。
    *   **目的**: 捕获词法/语法分析过程中产生的错误，收集错误信息（如行号、列号、错误消息），并将其以清晰的格式（如JSON）返回给前端，在编辑器中高亮显示或在单独的面板中列出。
    
3.  **创建Web编辑器前端**:
    *   **技术选型**: 使用原生 JavaScript + Monaco Editor + viz.js
    *   **任务细化**:
        *   3.1 **创建前端项目结构**: 创建 `webapp` 目录，设置基础文件结构（HTML、CSS、JS），引入 Monaco Editor 和 viz.js 依赖
        *   3.2 **实现代码编辑器界面**: 集成 Monaco Editor，配置 Rust 语法高亮，设置编辑器主题和基本配置
        *   3.3 **创建用户界面布局**: 设计整体页面布局（编辑器 + 结果展示区域），添加"分析"按钮和加载状态，创建结果展示的各个区域
        *   3.4 **实现与后端的通信**: 编写 API 调用函数，处理请求/响应的数据格式，添加错误处理和用户反馈
    *   **目录结构**:
        ```
        webapp/
        ├── index.html          # 主页面
        ├── css/
        │   └── styles.css      # 样式文件
        ├── js/
        │   ├── main.js         # 主逻辑
        │   ├── editor.js       # 编辑器相关
        │   ├── api.js          # API 调用
        │   └── visualizer.js   # 结果可视化
        └── lib/                # 第三方库
            ├── monaco-editor/
            └── viz.js
        ```

4.  **实现结果的可视化**:
    *   **任务细化**:
        *   4.1 **TokenStream 展示**: 设计 Token 列表的展示格式（表格或列表），实现 JSON 数据到前端展示的转换
        *   4.2 **ParseTree（CST）和 AST 可视化**: 
            *   **ParseTree（CST）可视化**：后端遍历ANTLR生成的ParseTree，输出LISP树和Graphviz `.dot` 字符串，前端用viz.js渲染为交互式语法树，完整反映源代码的语法结构。
            *   **AST（抽象语法树）可视化**：后端在ParseTree基础上归约生成AST，输出`.dot`字符串，前端同样用viz.js渲染，突出程序的语义结构和核心逻辑。
            *   **交互体验**：两种树均支持缩放、拖拽、节点高亮等交互，便于用户对比和理解不同层次的代码结构。
        *   4.3 **错误信息展示**: 设计错误信息的展示界面，实现代码行的错误高亮，创建错误列表面板
    *   **技术实现**:
        *   **TokenStream**: 修改后端逻辑，使其返回一个包含所有Token的列表（JSON格式），并在前端以表格形式展示
        *   **ParseTree（CST）和AST (使用Graphviz)**:
            *   后端：分别为ParseTree（CST）和AST实现遍历与归约逻辑，生成各自的Graphviz `.dot` 文件格式字符串。
            *   前端：接收到两种`.dot`字符串后，利用viz.js渲染为可交互的具体语法树和抽象语法树，支持切换、对比和结构分析。


## 第二阶段：语义分析与LLVM IR生成 (选做加分项)

这个阶段的目标是实现编译器的核心后端功能。

1.  **定义语义规则与构建符号表**:
    *   **任务**: 设计并实现一个符号表（Symbol Table）数据结构，用于存储变量、函数、类型等信息。
    *   **目的**: 在遍历AST时，根据Rust的语义规则（如作用域、类型检查）填充符号表。

2.  **遍历AST并生成LLVM IR**:
    *   **任务**: 再次遍历AST，利用符号表中的信息，生成LLVM中间表示（LLVM IR）。
    *   **目的**: 将高级的Rust代码转换为低级的、与机器无关的中间代码。可以考虑使用 LLVM的Java绑定库。

## 第三阶段：集成LLVM后端 (选做加分项)

1.  **调用LLVM后端**:
    *   **任务**: 将生成的LLVM IR输入到LLVM的后端工具链（如 `llc` 和 `clang`）。
    *   **目的**: 编译生成特定平台（如 x86, ARM）的可执行文件。